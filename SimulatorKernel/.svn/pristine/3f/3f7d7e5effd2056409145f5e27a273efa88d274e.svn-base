package br.ufpe.simulatorkernel.domain;

import java.util.Arrays;

import br.ufpe.simulator.exceptions.EonSimulatorExceptions;

public class SlotOccupancyCollection {

	private boolean[] slots;

	public SlotOccupancyCollection() {
		super();
	}

	public SlotOccupancyCollection(int numberSlots) {
		this();
		this.slots = new boolean[numberSlots];
	}

	public boolean getSlot(int index) {
		return slots[index];
	}

	public int getNumberSlots() {
		return this.slots.length;
	}

	public boolean hasOnlyUnoccupiedSlots() {
		boolean[] copy = new boolean[this.slots.length];
		return Arrays.equals(copy, this.slots);
	}

	public boolean[] getSlots() {
		return slots;
	}

	public void setSlots(boolean[] slots) {
		this.slots = slots;
	}

	public void setSlotsAsOccupied(int slotInitial, int slotFinal) {
		setSlotsOccupancy(slotInitial, slotFinal, true);
	}

	public void setSlotsAsUnoccupied(int slotInitial, int slotFinal) {
		setSlotsOccupancy(slotInitial, slotFinal, false);
	}

	private void setSlotsOccupancy(int slotInitial, int slotFinal,
			boolean setOccupied) {
		if (!(slotFinal >= slotInitial && slotInitial >= 0)) {
			throw new RuntimeException(
					EonSimulatorExceptions.SLOT_INDEX_NOT_VALID_EXCEPTION);
		}
		for (int i = slotInitial; i <= slotFinal; i++) {
			boolean isOccupied = slots[i];
			if (!(setOccupied && !isOccupied || !setOccupied && isOccupied)) {
				throw new RuntimeException(
						EonSimulatorExceptions.SLOT_OCCUPANCY_NOT_VALID_EXCEPTION);
			} else {
				slots[i] = setOccupied;
			}
		}
	}

	/**
	 * 
	 * @param ocSpectrumCollection
	 */
	public void mergeOccupancy(SlotOccupancyCollection ocSpectrumCollection) {
		for (int i = 0; i < ocSpectrumCollection.getNumberSlots(); i++) {
			if (!slots[i]) {
				boolean isOccupied = ocSpectrumCollection.getSlot(i);
				slots[i] = isOccupied;
			}
		}

	}

	public SlotOccupancyCollection clone() {
		SlotOccupancyCollection collection = new SlotOccupancyCollection();
		collection.setSlots(this.getSlots());
		return collection;
	}

}
