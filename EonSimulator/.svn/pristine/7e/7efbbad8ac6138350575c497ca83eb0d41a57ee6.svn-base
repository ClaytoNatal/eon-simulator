package br.ufpe.eonsimulator.rsa;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import br.ufpe.eonsimulator.domain.Connection;
import br.ufpe.eonsimulator.domain.OSNRUtils;
import br.ufpe.eonsimulator.domain.Route;
import br.ufpe.eonsimulator.domain.Simulation;
import br.ufpe.eonsimulator.modulation.IsModulationFormat;
import br.ufpe.simulator.math.MathUtils;
import br.ufpe.simulator.messages.MessageUtils;
import br.ufpe.simulator.utils.ConvertUtils;

public class RSAMaxNHopsNSlotsAlgorithm extends RSAAlgorithm {

	private class RSAMaxNHopsNSlotsWrapper extends RSAWrapper {

		public RSAMaxNHopsNSlotsWrapper(int index, boolean isPathValid,
				boolean isNHopsNSlotsValid, Route route,
				double requiredNHopsNSlots, int nSlots) {
			super(index, isPathValid, isNHopsNSlotsValid, route,
					requiredNHopsNSlots, nSlots);
		}

		@Override
		protected int compareToOtherEquals(RSAWrapper other) {
			int i = 0;
			if (other instanceof RSAMaxNHopsNSlotsWrapper) {
				RSAMaxNHopsNSlotsWrapper otherWrapper = (RSAMaxNHopsNSlotsWrapper) other;
				int thisNHopsNSlots = getRoute().getNHops() * this.getnSlots();
				int otherNHopsNSlots = other.getRoute().getNHops()
						* otherWrapper.getnSlots();
				if (thisNHopsNSlots < otherNHopsNSlots) {
					i = -1;
				} else if (thisNHopsNSlots > otherNHopsNSlots) {
					i = 1;
				}
			}
			return i;
		}

	}

	@Override
	protected RSAWrapper createRSAWrapper(int index, Route route,
			Simulation simulation, Connection connection,
			IsModulationFormat modulationFormat, int nSlots) {
		return new RSAMaxNHopsNSlotsWrapper(index, route.isPathValid(),
				OSNRUtils.isValidOSNR(simulation, connection, route,
						modulationFormat.getNSymbol()), route,
				connection.getRequiredOSNR(), nSlots);
	}

	@Override
	public RSAWrapper getRSAWrapper(List<Route> routes, Simulation simulation,
			Connection connection) {
		RSAWrapper routeWrapper = null;
		List<RSAWrapper> routeWrappers = new ArrayList<RSAWrapper>();
		Iterator<IsModulationFormat> modulationFormatIterator = simulation
				.getModulationFormats().iterator();
		while (modulationFormatIterator.hasNext()) {
			IsModulationFormat modulationFormat = modulationFormatIterator
					.next();
			connection.setNumberSlotRequired(modulationFormat
					.createNumberOfRequiredSlots(simulation,
							connection.getRequestedBitRate()));

			connection.setRequiredOSNR(modulationFormat.createRequiredOSNR(
					simulation, connection.getRequestedBitRate()));

			for (Route route : routes) {
				// Try to assign a wavelength to each path, using the WA
				simulation.getIsAssignmentAlgorithm().trySpectrumAssignment(
						connection, route);
				RSAWrapper routeWrapper2 = createRSAWrapper(
						routes.indexOf(route), route, simulation, connection,
						modulationFormat, connection.getNumberSlotRequired());
				routeWrappers.add(routeWrapper2);
			}
		}
		Collections.sort(routeWrappers);
		List<RSAWrapper> pathWrappers = new ArrayList<RSAWrapper>();
		for (RSAWrapper rsaWrapper : routeWrappers) {
			if (rsaWrapper.isPathValid()) {
				pathWrappers.add(rsaWrapper);
			}
		}
		simulation.getSimulationResults().incrementNumberOfPhysicalValidRoutes(
				pathWrappers.size());
		for (RSAWrapper rsaWrapper : pathWrappers) {
			routeWrapper = rsaWrapper;
			connection.setNumberSlotRequired(routeWrapper.getnSlots());
			connection.setRequiredOSNR(routeWrapper.getRequiredOSNR());
			if (rsaWrapper.isValid()) {
				if (logger.isInfoEnabled()) {
					logger.info(MessageUtils.createMessage(
							SIMULATION_ROUTE_BESTROUTE_INFO, routeWrapper
									.getRoute().getSeparatedElementsIndex(),
							routeWrapper.isPathValid(), routeWrapper
									.isOSNRValid(), connection
									.getNumberSlotRequired(), connection
									.getRequestedBitRate(), ConvertUtils
									.convertToString(MathUtils
											.convertLinearTodB(connection
													.getRequiredOSNR()))));
				}
				break;
			}

		}
		return routeWrapper;
	}

}
