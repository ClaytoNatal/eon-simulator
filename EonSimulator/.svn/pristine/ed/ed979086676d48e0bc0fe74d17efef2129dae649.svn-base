package br.ufpe.eonsimulator.domain;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import br.ufpe.simulatorkernel.domain.IsPhysicalElement;
import br.ufpe.simulatorkernel.domain.Link;

public class Topology {

	private class PhysicalElementIndexPair {

		private int sourceIndex;
		private int targetIndex;

		public PhysicalElementIndexPair(int sourceIndex, int targetIndex) {
			super();
			this.sourceIndex = sourceIndex;
			this.targetIndex = targetIndex;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + sourceIndex;
			result = prime * result + targetIndex;
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			PhysicalElementIndexPair other = (PhysicalElementIndexPair) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (sourceIndex != other.sourceIndex)
				return false;
			if (targetIndex != other.targetIndex)
				return false;
			return true;
		}

		private Topology getOuterType() {
			return Topology.this;
		}

	}

	private List<Link> links;
	private List<IsPhysicalElement> physicalElements;
	private Map<PhysicalElementIndexPair, Link> indexMap;

	public Topology() {
		super();
		this.links = new ArrayList<Link>();
		this.physicalElements = new ArrayList<IsPhysicalElement>();
		this.indexMap = new HashMap<Topology.PhysicalElementIndexPair, Link>();
	}

	public List<Link> getLinks() {
		return links;
	}

	public void disconnect(Route route) {
		connect(route, false);
	}

	public void connect(Route route) {
		connect(route, true);
	}

	private void connect(Route route, boolean doConnection) {
		for (Link link : route.getLinks()) {
			Link dualLink = getDualLink(link);
			if (doConnection) {// Insert the connection
				link.getOcSpectrumCollection().setSlotsAsOccupied(
						route.getInitialSlot(), route.getFinalSlot());
				if (dualLink != null)
					dualLink.getOcSpectrumCollection().setSlotsAsOccupied(
							route.getInitialSlot(), route.getFinalSlot());
			} else {
				// Remove the connection
				link.getOcSpectrumCollection().setSlotsAsUnoccupied(
						route.getInitialSlot(), route.getFinalSlot());
				if (dualLink != null)
					dualLink.getOcSpectrumCollection().setSlotsAsUnoccupied(
							route.getInitialSlot(), route.getFinalSlot());
			}
		}
	}

	public Route getDualRoute(Route route) {
		Route dualRoute = new Route();
		dualRoute.setInitialSlot(route.getInitialSlot());
		dualRoute.setFinalSlot(route.getFinalSlot());
		for (Link link : route.getLinks()) {
			dualRoute.addLinkLastPosition(getDualLink(link));
		}
		return dualRoute;
	}

	private Link getDualLink(Link link) {
		Link dual = null;
		for (Link temp : links) {
			if (temp.isDual(link)) {
				dual = temp;
				break;
			}
		}
		return dual;
	}

	public boolean isClean() { // Checks whether all links are unoccupied
		boolean isClean = true;
		if (links != null) {
			for (Link link : links) {
				if (!link.getOcSpectrumCollection().hasOnlyUnoccupiedSlots()) {
					isClean = false;
					break;
				}
			}
		}
		return isClean;
	}

	public void add(Link link) {
		this.links.add(link);
		addIndexLink(link);
		addPhysicalElementIfNotExists(link.getSourceNode());
		addPhysicalElementIfNotExists(link.getTargetNode());
	}

	private void addPhysicalElementIfNotExists(IsPhysicalElement physicalElement) {
		if (!this.physicalElements.contains(physicalElement)) {
			this.physicalElements.add(physicalElement);
		}
	}

	public List<IsPhysicalElement> getPhysicalElements() {
		return this.physicalElements;
	}

	private void addIndexLink(Link link) {
		int sourceIndex = link.getSourceNode().getIndex();
		int targetIndex = link.getTargetNode().getIndex();
		PhysicalElementIndexPair elementIndexPair = new PhysicalElementIndexPair(
				sourceIndex, targetIndex);
		indexMap.put(elementIndexPair, link);
	}

	public Link getLink(int sourceIndex, int targetIndex) {
		PhysicalElementIndexPair elementIndexPair = new PhysicalElementIndexPair(
				sourceIndex, targetIndex);
		return indexMap.get(elementIndexPair);
	}

	public int getPhysicalElementIndex(IsPhysicalElement isPhysicalElement) {
		return physicalElements.indexOf(isPhysicalElement);
	}

	public IsPhysicalElement getPhysicalElement(int index) {
		return physicalElements.get(index);
	}
}
